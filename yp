#!/usr/bin/perl -w -I.

# ===========================================================================
# File:		yp
# Purpose:	Generator for a Yawns-Planet website.
# Created:	2005-10-12
#
# ===========================================================================
# (c) 2005 Steve Kemp <steve@steve.org.uk>
# This program is free software; you can redistribute it and/or modify 
# it under the terms of version 2 of the GNU General Public License as 
# published by the Free Software Foundation.  See the file COPYING for 
# further details.
# ===========================================================================
#
# $Id: yp,v 1.20 2005-10-13 13:19:26 steve Exp $

# Enforce good programming practices
use strict;

# Modules we use.
use Date::Manip qw(ParseDate UnixDate Date_ConvTZ);
use HTML::Entities;
use HTML::Template;
use POSIX qw/ strftime /;


# Custom modules
use conf::SiteConfig;
use Singleton::DBI;


#
# Read-only variables: version number from CVS.
#
my $REVISION  = '$Id: yp,v 1.20 2005-10-13 13:19:26 steve Exp $';
my $VERSION   = "";
$VERSION      = join (' ', (split (' ', $REVISION))[2..2]);
$VERSION      =~ s/yp,v\b//;





#
#  1. Connect to the database
#
my $dbh = Singleton::DBI->instance();


#  2. Get weblog entries.
#
my @entries = getWeblogs( $dbh, get_conf( "count" ) );

#
#  3. Create output HTML
#
writeHTMLIndex( @entries );


#
#  4. Create output XML feeds.
# 
writeRSS10( @entries );
writeRSS20( @entries );


#
#  5. Disconnect from database.
#
$dbh->disconnect();




#
#  Return the relevent weblog entries from the database
#
sub getWeblogs
{
    my ( $dbh, $count ) = ( @_ );

    #
    # Execute the query
    #
    my $sql = $dbh->prepare( 'SELECT id, username, title, bodytext,  date_format( ondate, "%D %M %Y" ), TIME( ondate ),comments FROM weblogs ORDER BY ondate DESC LIMIT 0,' . $count );
    $sql->execute( );


    my $dataref = $sql->fetchall_arrayref;
    my $len = @$dataref;

    my $weblogs  = [];
    my $prevDate = '';

    for ( my $l = 0; $l < $len; $l++ ) 
    {
	my $entry = @$dataref[$l];
	my @entry = @$entry;


	#
	# 0 comments
	# 1 comment
	# 2 comments 
	# ..
	my $comments = $entry[6];
	my $plural = 1;
	if ( $comments eq 1 )
	{
	   $plural = 0;
	}
	
	#
	# Check for new date
	#
	my $new_date = 0;
	my $date     = $entry[4];
	my $time     = $entry[5];
	if ( $date ne $prevDate )
	{
	    $new_date = 1;
	}
	$prevDate = $date;


	#
	# Check for comments being disabled
	#
	my $comments_disabled = 0;
	if ( $comments <  0 )
	{
	    $comments_disabled = 1;
	}

	#
	# Show different text if there are no comments.
	#
	my $no_comments = 0;
	if ( $comments ==  0 )
	{
	    $no_comments = 1;
	}

	push ( @$weblogs,
	       {
		   id          => $entry[0],
		   user        => $entry[1],
		   title       => $entry[2],
		   body        => $entry[3],
		   date        => $date,
		   time        => $time,
		   comments    => $comments,
		   no_comments => $no_comments,
		   disabled    => $comments_disabled,
		   plural      => $plural,
		   new_date    => $new_date,
	       } );
    }

    return( $weblogs );
}



#
#  Return the list of subscribed users.
#
sub getSubscriptions
{
    my ($dbh ) = Singleton::DBI->instance();

    #
    # Find the posters.
    #
    my $query = "SELECT DISTINCT a.realname,a.username FROM users AS a INNER JOIN weblogs AS b ON a.username = b.username";

    my $sql = $dbh->prepare( $query );
    $sql->execute();

    #
    # Get all the results.
    #
    my $dataref  = $sql->fetchall_arrayref();
    my @datalist = @$dataref;
    $sql->finish();

    # Data from the query
    my $user = ();
    my $subscriptions = [];

    foreach my $data ( @datalist )
    {
	my @user = @$data;

	#
	#  Find the data.
	#
	my $real_name = $user[0];
	my $user_name = $user[1];

	#
	# If the use has no real name set then use their account name.
	#
	if (! $real_name )
	{
	    $real_name = $user_name ;
	}

	$real_name = encode_entities( $real_name );
	push ( @$subscriptions,
	       {
		   account => $user_name,
		   fullname => $real_name
		   });

    }


    #
    # Sort the subscriptions appropriately.
    #
    @$subscriptions = sort sortByName @$subscriptions;

    return( $subscriptions );
}




#
# Sort a list of subscriptions by their username, case-insensitive.
#
sub sortByName()
{
    return( lc($::a->{'fullname'}) cmp lc($::b->{'fullname'}) );
}




#
#  Write the output index.html file
#
sub writeHTMLIndex 
{
    my ( @entries ) = ( @_ );

    #
    # Load the template.
    #
    my $template = HTML::Template->new( filename => "templates/index.tmpl" );

    #
    # Add the blogs and subscription information.
    #
    $template->param( 'blogs', @entries );
    $template->param( 'subscriptions', getSubscriptions( ) );

    my $time = strftime ("%e %B %Y - %H:%M:%S", localtime);

    #
    # Setup static parameters.
    #
    $template->param( 'title',      get_conf( 'title' ) );
    $template->param( 'title_link', get_conf( 'title_link' ) );
    $template->param( 'updated' ,   $time );
    $template->param( 'version' ,   $VERSION );


    #
    # Open the output file, and write the data.
    #
    my $output = get_conf( "htmlOutput" );

    open( OUTPUT, ">", $output )
	or die "Cannot open output file '$output' - $!@";
    print OUTPUT $template->output();
    close( OUTPUT );
}


#
#  Write out an RSS v1.0 formatted XML file from the weblog
# entries.
#
#  We do this cleanly setting each template loop's value
# correctly - taking care to modify the date to the appropriate
# format.
#
sub writeRSS10 
{
    my ( $weblogs ) = ( @_ );

    my $contents;
    my $entries;

    #
    # Read in each available blog entry.  We don't care about
    # much of the date just:
    #
    # Username, ID, title, body, and date.
    #
    foreach my $entry ( @$weblogs )
    {
	my $title = $entry->{'title'};
	my $user  = $entry->{'user'};
	my $id    = $entry->{'id'};
	my $body  = $entry->{'body'};
	my $date  = $entry->{'date'};
	my $time  = $entry->{'time'};


	#
	#  Make sure the date is in the right format for
	# the RSS v1.0 feed.
	#
	my $dp  = ParseDate( $time . " " . $date );
	$date = UnixDate( $dp, "%Y-%m-%dT%H:%M:00+00:00");

	#
	#  HTML Encode the title, and body, so that it is valid.
	#
	$title = encode_entities( $title );
	$body  = encode_entities( $body );
	push( @$contents,
	      {
		  username => $user,
		  id       => $id,
	      } );
	
	push( @$entries,
	      {
		  username => $user,
		  id       => $id,
		  title    => $title,
		  bodytext => $body,
		  date     => $date
		  } );
	
    }

    #
    # Load the template.
    #
    my $template = HTML::Template->new( filename => "templates/rss10.tmpl" );


    #
    #  Set the parameters
    #
    $template->param( "contents", $contents );
    $template->param( "blogentries", $entries );

    #
    # Open the output file, and write the data.
    #
    my $output = get_conf( "rss1Output" );
    open( RSS10OUTPUT, ">", $output )
	or die "Cannot open output file '$output' - $!@";
    print RSS10OUTPUT $template->output();
    close( RSS10OUTPUT );
}



#
#  Write out an RSS v2.0 formatted XML file from the weblog
# entries.
#
#  We do this cleanly setting each template loop's value
# correctly - taking care to modify the date to the appropriate
# format.
#
sub writeRSS20
{
    my ( $weblogs ) = ( @_ );

    my $entries;

    #
    # Read in each available blog entry.  We don't care about
    # much of the date just:
    #
    # Username, ID, title, body, and date.
    #
    foreach my $entry ( @$weblogs )
    {
	my $title = $entry->{'title'};
	my $user  = $entry->{'user'};
	my $id    = $entry->{'id'};
	my $body  = $entry->{'body'};
	my $date  = $entry->{'date'};
	my $time  = $entry->{'time'};


	#
	#  Make sure the date is in the right format for
	# the RSS v2.0 feed.
	#
	# e.g.
	#      Sat, 10 Sep 2005 02:44:00 +0000
	#
	my $dp  = ParseDate( $time . " " . $date );
	$date = UnixDate( $dp, "%a, %d %b %Y %H:%M:%S +0000" );

	#
	#  HTML Encode the title, and body, so that it is valid.
	#
	$title = encode_entities( $title );
	$body  = encode_entities( $body );

	push( @$entries,
	      {
		  username => $user,
		  id       => $id,
		  title    => $title,
		  bodytext => $body,
		  date     => $date
		  } );
	
    }

    #
    # Load the template.
    #
    my $template = HTML::Template->new( filename => "templates/rss20.tmpl" );


    #
    #  Setup the entries.
    #
    $template->param( "entries", $entries );

    #
    # Open the output file, and write the data.
    #
    my $output = get_conf( "rss2Output" );
    open( OUTPUT, ">", $output ) 
	or die "Cannot open output file '$output' - $!@";
    print OUTPUT $template->output();
    close( OUTPUT );
}
